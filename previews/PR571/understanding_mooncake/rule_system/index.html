<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mooncake.jl&#39;s Rule System · Mooncake.jl</title><meta name="title" content="Mooncake.jl&#39;s Rule System · Mooncake.jl"/><meta property="og:title" content="Mooncake.jl&#39;s Rule System · Mooncake.jl"/><meta property="twitter:title" content="Mooncake.jl&#39;s Rule System · Mooncake.jl"/><meta name="description" content="Documentation for Mooncake.jl."/><meta property="og:description" content="Documentation for Mooncake.jl."/><meta property="twitter:description" content="Documentation for Mooncake.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Mooncake.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Mooncake.jl</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../interface/">Interface</a></li><li><span class="tocitem">Understanding Mooncake.jl</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../algorithmic_differentiation/">Algorithmic Differentiation</a></li><li class="is-active"><a class="tocitem" href>Mooncake.jl&#39;s Rule System</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#10,000-Foot-View"><span>10,000 Foot View</span></a></li><li class="toplevel"><a class="tocitem" href="#A-Model-For-A-Julia-Function"><span>A Model For A Julia Function</span></a></li><li class="toplevel"><a class="tocitem" href="#The-Rule-Interface-(Round-1)"><span>The Rule Interface (Round 1)</span></a></li><li class="toplevel"><a class="tocitem" href="#Representing-Gradients"><span>Representing Gradients</span></a></li><li class="toplevel"><a class="tocitem" href="#The-Rule-Interface-(Round-2)"><span>The Rule Interface (Round 2)</span></a></li><li class="toplevel"><a class="tocitem" href="#Testing"><span>Testing</span></a></li><li class="toplevel"><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li class="toplevel"><a class="tocitem" href="#Asides"><span>Asides</span></a></li></ul></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../../utilities/defining_rules/">Defining Rules</a></li><li><a class="tocitem" href="../../utilities/debug_mode/">Debug Mode</a></li><li><a class="tocitem" href="../../utilities/debugging_and_mwes/">Debugging and MWEs</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../developer_documentation/running_tests_locally/">Running Tests Locally</a></li><li><a class="tocitem" href="../../developer_documentation/developer_tools/">Developer Tools</a></li><li><a class="tocitem" href="../../developer_documentation/ir_representation/">IR Representation</a></li><li><a class="tocitem" href="../../developer_documentation/forwards_mode_design/">Forwards-Mode Design</a></li><li><a class="tocitem" href="../../developer_documentation/reverse_mode_design/">Reverse-Mode Design</a></li><li><a class="tocitem" href="../../developer_documentation/misc_internals_notes/">Misc. Internals Notes</a></li><li><a class="tocitem" href="../../developer_documentation/internal_docstrings/">Internal Docstrings</a></li></ul></li><li><a class="tocitem" href="../../known_limitations/">Known Limitations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Understanding Mooncake.jl</a></li><li class="is-active"><a href>Mooncake.jl&#39;s Rule System</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mooncake.jl&#39;s Rule System</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chalk-lab/Mooncake.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chalk-lab/Mooncake.jl/blob/main/docs/src/understanding_mooncake/rule_system.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mooncake.jl&#39;s-Rule-System"><a class="docs-heading-anchor" href="#Mooncake.jl&#39;s-Rule-System">Mooncake.jl&#39;s Rule System</a><a id="Mooncake.jl&#39;s-Rule-System-1"></a><a class="docs-heading-anchor-permalink" href="#Mooncake.jl&#39;s-Rule-System" title="Permalink"></a></h1><p>Mooncake.jl&#39;s approach to AD is recursive. It has a single specification for <em>what</em> it means to differentiate a Julia callable, and basically two approaches to achieving this. This section of the documentation explains the former.</p><p>We take an iterative approach to this explanation, starting at a high-level and adding more depth as we go.</p><h1 id="10,000-Foot-View"><a class="docs-heading-anchor" href="#10,000-Foot-View">10,000 Foot View</a><a id="10,000-Foot-View-1"></a><a class="docs-heading-anchor-permalink" href="#10,000-Foot-View" title="Permalink"></a></h1><p>A rule <code>r(f, x)</code> for a <code>function</code> <code>f(x)</code> &quot;does reverse mode AD&quot;, and executes in two phases, known as the forwards pass and the reverse pass. In the forwards pass a rule executes the original <code>function</code>, and does some additional book-keeping in preparation for the reverse pass. On the reverse pass it undoes the computation from the forwards pass, &quot;backpropagates&quot; the gradient w.r.t. the output of the original function by applying the adjoint of the derivative of the original <code>function</code> to it, and writes the results of this computation to the correct places.</p><p>A precise mathematical model for the original function is therefore entirely crucial to this discussion, as it is needed to understand what the adjoint of its derivative is.</p><h1 id="A-Model-For-A-Julia-Function"><a class="docs-heading-anchor" href="#A-Model-For-A-Julia-Function">A Model For A Julia Function</a><a id="A-Model-For-A-Julia-Function-1"></a><a class="docs-heading-anchor-permalink" href="#A-Model-For-A-Julia-Function" title="Permalink"></a></h1><p>Since Julia permits the in-place modification / mutation of many data structures, we cannot make a naive translation between a Julia function and a mathematical object. Rather, we will have to model the state of the arguments to a function both before and after execution. Moreover, since a function can allocate new memory as part of execution and return it to the calling scope, we must track that too.</p><h3 id="Consider-Only-Externally-Visible-Effects-Of-Function-Evaluation"><a class="docs-heading-anchor" href="#Consider-Only-Externally-Visible-Effects-Of-Function-Evaluation">Consider Only Externally-Visible Effects Of Function Evaluation</a><a id="Consider-Only-Externally-Visible-Effects-Of-Function-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Consider-Only-Externally-Visible-Effects-Of-Function-Evaluation" title="Permalink"></a></h3><p>We wish to treat a given <code>function</code> as a black box – we care about <em>what</em> a <code>function</code> does, not <em>how</em> it does it – so we consider only the externally-visible results of executing it. There are two ways in which changes can be made externally visible.</p><p><em><strong>Return Value</strong></em></p><p>(This point hardly requires explanation, but for the sake of completeness we do so anyway.)</p><p>The most obvious way in which a result can be made visible outside of a <code>function</code> is via its return value. For example, letting <code>bar(x) = sin(x)</code>, consider the function</p><pre><code class="language-julia hljs">function foo(x)
    y = bar(x)
    z = bar(y)
    return z
end</code></pre><p>The communication between the two invocations of <code>bar</code> happen via the value it <code>return</code>s.</p><p><em><strong>Modification of arguments</strong></em></p><p>In contrast to the above, changes made by one <code>function</code> can be made available to another implicitly if it modifies the values of its arguments, even if it doesn&#39;t return anything. For example, consider:</p><pre><code class="language-julia hljs">function bar(x::Vector{Float64})
    x .*= 2
    return nothing
end

function foo(x::Vector{Float64})
    bar(x)
    bar(x)
    return x
end</code></pre><p>The second call to <code>bar</code> in <code>foo</code> sees the changes made to <code>x</code> by the first call to <code>bar</code>, despite not being explicitly returned.</p><p><em><strong>No Global Mutable State</strong></em></p><p><code>function</code>s can in principle also communicate via <code>global</code> mutable state. We make the decision to <em>not</em> support this.</p><p>For example, we assume <code>function</code>s of the following form cannot be encountered:</p><pre><code class="language-julia hljs">const a = randn(10)

function bar(x)
    a .+= x
    return nothing
end

function foo(x)
    bar(x)
    return a
end</code></pre><p>In this example, <code>a</code> is modified by <code>bar</code>, the effect of which is visible to <code>foo</code>.</p><p>For a variety of reasons this is very awkward to handle well. Since it&#39;s largely considered poor practice anyway, we explicitly outlaw this mode of communication between <code>function</code>s. See <a href="#Why-Support-Closures-But-Not-Mutable-Globals">Why Support Closures But Not Mutable Globals</a> for more info.</p><p>Note that this does not preclude the use of closed-over values or callable <code>struct</code>s. For example, something like</p><pre><code class="language-julia hljs">function foo(x)
    function bar(y)
        x .+= y
        return nothing
    end
    return bar(x)
end</code></pre><p>is perfectly fine.</p><h3 id="The-Model"><a class="docs-heading-anchor" href="#The-Model">The Model</a><a id="The-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-Model" title="Permalink"></a></h3><p>It is helpful to have a concrete example which uses both of the permissible methods to make results externally visible. To this end, consider the following <code>function</code>:</p><pre><code class="language-julia hljs">function f(x::Vector{Float64}, y::Vector{Float64}, z::Vector{Float64}, s::Ref{Vector{Float64}})
    z .*= y .* x
    s[] = 2z
    return sum(z)
end</code></pre><p>We draw your attention to a variety of features of this <code>function</code>:</p><ol><li><code>z</code> is mutated,</li><li><code>s</code> is mutated to reference freshly allocated memory,</li><li>the value previously pointed to by <code>s</code> is unmodified, and</li><li>we allocate a new value and return it (albeit, it is probably allocated on the stack).</li></ol><p>The model we adopt for any Julia <code>function</code> <code>f</code> is a function <span>$f : \mathcal{X} \to \mathcal{X} \times \mathcal{A}$</span> where <span>$\mathcal{X}$</span> is the real finite Hilbert space associated to the arguments to <code>f</code> prior to execution, and <span>$\mathcal{A}$</span> is the real finite Hilbert space associated to any newly allocated data during execution which is externally visible after execution – any newly allocated data which is not made visible is of no concern.</p><p>In this example, <span>$\mathcal{X} = \RR^D \times \RR^D \times \RR^D \times \RR^S$</span> where <span>$D$</span> is the length of <code>x</code> / <code>y</code> / <code>z</code>, and <span>$S$</span> the length of <code>s[]</code> prior to running <code>f</code>. <span>$\mathcal{A} = \RR^D \times \RR$</span>, where the <span>$\RR^D$</span> component corresponds to the freshly allocated memory that <code>s</code> references, and <span>$\RR$</span> to the return value. Observe that we model <code>Float64</code>s as elements of <span>$\RR$</span>, <code>Vector{Float64}</code>s as elements of <span>$\RR^D$</span> (for some value of <span>$D$</span>), and <code>Ref</code>s with whatever the model for their contents is. The keen-eyed reader will note that these choices abstract away several details which could conceivably be included in the model. In particular, <code>Vector{Float64}</code> is implemented via a memory buffer, a pointer to the start of this buffer, and an integer which indicates the length of this buffer – none of these details are exposed in the model.</p><p>In this example, some of the memory allocated during execution is made externally visible by modifying one of the arguments, not just via the return value.</p><p>The argument to <span>$f$</span> is the arguments to <code>f</code> <em>before</em> execution, and the output is the 2-tuple comprising the same arguments <em>after</em> execution and the values associated to any newly allocated / created data. Crucially, observe that we distinguish between the state of the arguments before and after execution.</p><p>For our example, the exact form of <span>$f$</span> is</p><p class="math-container">\[f((x, y, z, s)) = ((x, y, x \odot y, s), (2 x \odot y, \sum_{d=1}^D x \odot y))\]</p><p>Observe that <span>$f$</span> behaves a little like a transition operator, in the that the first element of the tuple returned is the updated state of the arguments.</p><p>This model is good enough for the vast majority of functions. Unfortunately it isn&#39;t sufficient to describe a <code>function</code> when arguments alias each other (e.g. consider the way in which this particular model is wrong if <code>y</code> aliases <code>z</code>). Fortunately this is only a problem in a small fraction of all cases of aliasing, so we defer discussion of this until later on.</p><p>Consider now how this approach can be used to model several additional Julia functions, and to obtain their derivatives and adjoints.</p><p><em><strong><code>sin(x::Float64)</code></strong></em></p><p><span>$\mathcal{X} = \RR$</span>, <span>$\mathcal{A} = \RR$</span>, <span>$f(x) = (x, \sin(x))$</span>.</p><p>Thus the derivative is <span>$D f [x] (\dot{x}) = (\dot{x}, \cos(x) \dot{x})$</span>, and its adjoint is <span>$D f [x]^\ast (\bar{y}) = \bar{y}_x + \bar{y}_a \cos(x)$</span>, where <span>$\bar{y} = (\bar{y}_x, \bar{y}_a)$</span>.</p><p>Observe that this result is slightly different to the last example we saw involving <code>sin</code>.</p><p><em><strong>AD With Mutable Data</strong></em></p><p>Consider again</p><pre><code class="language-julia hljs">function f!(x::Vector{Float64})
    x .*= x
    return sum(x)
end</code></pre><p>Our framework is able to accomodate this function, and has essentially the same solution as the last time we saw this example:</p><p class="math-container">\[f(x) = (x \odot x, \sum_{n=1}^N x_n^2)\]</p><p><em><strong>Non-Mutating Functions</strong></em></p><p>A very interesting class of functions are those which do not modify their arguments. These are interesting because they are common, and are all that many AD frameworks like ChainRules.jl / Zygote.jl support – by considering this class of functions, we highlight some key similarities between these distinct rule systems.</p><p>As always we can model these kinds of <code>function</code>s with a function <span>$f : \mathcal{X} \to \mathcal{X} \times \mathcal{A}$</span>, but we additionally have that <span>$f$</span> must have the form</p><p class="math-container">\[f(x) = (x, \varphi(x))\]</p><p>for some function <span>$\varphi : \mathcal{X} \to \mathcal{A}$</span>. The derivative is</p><p class="math-container">\[D f [x] (\dot{x}) = (\dot{x}, D \varphi [x](\dot{x})).\]</p><p>Consider the usual inner product to derive the adjoint:</p><p class="math-container">\[\begin{align}
    \langle \bar{y}, D f [x] (\dot{x}) \rangle &amp;= \langle (\bar{y}_1, \bar{y}_2), (\dot{x}, D \varphi [x](\dot{x})) \rangle \nonumber \\
        &amp;= \langle \bar{y}_1, \dot{x} \rangle + \langle \bar{y}_2, D \varphi [x](\dot{x}) \rangle \nonumber \\
        &amp;= \langle \bar{y}_1, \dot{x} \rangle + \langle D \varphi [x]^\ast (\bar{y}_2), \dot{x} \rangle \nonumber \quad \text{(by definition of the adjoint)} \\
        &amp;= \langle \bar{y}_1 + D \varphi [x]^\ast (\bar{y}_2), \dot{x} \rangle. \nonumber
\end{align}\]</p><p>So the adjoint of the derivative is</p><p class="math-container">\[D f [x]^\ast (\bar{y}) =  \bar{y}_1 + D \varphi [x]^\ast (\bar{y}_2).\]</p><p>We see the correct thing to do is to increment the gradient of the output – <span>$\bar{y}_1$</span> – by the result of applying the adjoint of the derivative of <span>$\varphi$</span> to <span>$\bar{y}_2$</span>. In a <code>ChainRules.rrule</code> the <span>$\bar{y}_1$</span> term is always zero, but the <span>$D \varphi [x]^\ast (\bar{y}_2)$</span> term is essentially the same.</p><h1 id="The-Rule-Interface-(Round-1)"><a class="docs-heading-anchor" href="#The-Rule-Interface-(Round-1)">The Rule Interface (Round 1)</a><a id="The-Rule-Interface-(Round-1)-1"></a><a class="docs-heading-anchor-permalink" href="#The-Rule-Interface-(Round-1)" title="Permalink"></a></h1><p>Having explained in principle what it is that a rule must do, we now take a first look at the interface we use to achieve this. A rule for a <code>function</code> <code>foo</code> with signature</p><pre><code class="language-julia hljs">Tuple{typeof(foo), Float64} -&gt; Float64</code></pre><p>must have signature</p><pre><code class="language-julia hljs">Tuple{Trule, CoDual{typeof(foo), NoFData}, CoDual{Float64, NoFData}} -&gt;
    Tuple{CoDual{Float64, NoFData}, Trvs_pass}</code></pre><p>For example, if we call <code>foo(5.0)</code>, it rules would be called as <code>rule(CoDual(foo, NoFData()), CoDual(5.0, NoFData()))</code>. The precise definition and role of <code>NoFData</code> will be explained shortly, but the general scheme is that to a rule for <code>foo</code> you must pass <code>foo</code> itself, its arguments, and some additional data for book-keeping. <code>foo</code> and each of its arguments are paired with this additional book-keeping data via the <code>CoDual</code> type.</p><p>The rule returns another <code>CoDual</code> (it propagates book-keeping information forwards), along with a <code>function</code> which runs the reverse pass.</p><p>In a little more depth:</p><p><em><strong>Notation: primal</strong></em></p><p>Throughout the rest of this document, we will refer to the <code>function</code> being differentiated as the &quot;primal&quot; computation, and its arguments as the &quot;primal&quot; arguments.</p><h3 id="Forwards-Pass"><a class="docs-heading-anchor" href="#Forwards-Pass">Forwards Pass</a><a id="Forwards-Pass-1"></a><a class="docs-heading-anchor-permalink" href="#Forwards-Pass" title="Permalink"></a></h3><p><em><strong>Inputs</strong></em></p><p>Each piece of each input to the primal is paired with shadow data, if it has a fixed address. For example, a <code>Vector{Float64}</code> argument is paired with another <code>Vector{Float64}</code>. The adjoint of <code>f</code> is accumulated into this shadow vector on the reverse pass. However, a <code>Float64</code> argument gets paired with <code>NoFData()</code>, since it is a bits type and therefore has no fixed address.</p><p><em><strong>Outputs</strong></em></p><p>A rule must return a <code>Tuple</code> of two things. The first thing must be a <code>CoDual</code> containing the output of the primal computation and its shadow memory (if it has any). The second must be a function which runs the reverse pass of AD – this will usually be a closure of some kind.</p><p><em><strong>Functionality</strong></em></p><p>A rule must</p><ol><li>ensure that the state of the primal components of all inputs / the output are as they would have been had the primal computation been run (up to differences due to finite precision arithmetic),</li><li>propagate / construct the shadow memory associated to the output (initialised to zero), and</li><li>construct the function to run the reverse pass – typically this will involve storing some quantities computed during the forwards pass.</li></ol><h3 id="Reverse-Pass"><a class="docs-heading-anchor" href="#Reverse-Pass">Reverse Pass</a><a id="Reverse-Pass-1"></a><a class="docs-heading-anchor-permalink" href="#Reverse-Pass" title="Permalink"></a></h3><p>The second element of the output of a rule is a function which runs the reverse pass.</p><p><em><strong>Inputs</strong></em></p><p>The &quot;rdata&quot; associated to the output of the primal.</p><p><em><strong>Outputs</strong></em></p><p>The &quot;rdata&quot; associated to the inputs of the primal.</p><p><em><strong>Functionality</strong></em></p><ol><li>undo changes made to primal state on the forwards pass.</li><li>apply adjoint of derivative of primal operation, putting the results in the correct place.</li></ol><p>This description should leave you with (at least) a couple of questions. What is &quot;rdata&quot;, and what is &quot;the correct place&quot; to put the results of applying the adjoint of the derivative? In order to address these, we need to discuss the types that Mooncake.jl uses to represent the results of AD, and to propagate results backwards on the reverse pass.</p><h1 id="Representing-Gradients"><a class="docs-heading-anchor" href="#Representing-Gradients">Representing Gradients</a><a id="Representing-Gradients-1"></a><a class="docs-heading-anchor-permalink" href="#Representing-Gradients" title="Permalink"></a></h1><p>We refer to both inputs and outputs of derivatives <span>$D f [x] : \mathcal{X} \to \mathcal{Y}$</span> as <em>tangents</em>, e.g. <span>$\dot{x}$</span> or <span>$\dot{y}$</span>. Conversely, we refer to both inputs and outputs to the adjoint of this derivative <span>$D f [x]^\ast : \mathcal{Y} \to \mathcal{X}$</span> as <em>gradients</em>, e.g. <span>$\bar{y}$</span> and <span>$\bar{x}$</span>.</p><p>Note, however, that the sets involved are the same whether dealing with a derivative or its adjoint. Consequently, we use the same type to represent both.</p><p><em><strong>Representing Gradients</strong></em></p><p>This package assigns to each type in Julia a unique <code>tangent_type</code>, the purpose of which is to contain the gradients computed during reverse mode AD. The extended docstring for <a href="../../developer_documentation/misc_internals_notes/#tangent_type"><code>tangent_type</code></a> provides the best introduction to the types which are used to represent tangents / gradients.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.tangent_type-Tuple{Any}-understanding_mooncake-rule_system" href="#Mooncake.tangent_type-Tuple{Any}-understanding_mooncake-rule_system"><code>Mooncake.tangent_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tangent_type(P)</code></pre><p>There must be a single type used to represents tangents of primals of type <code>P</code>, and it must be given by <code>tangent_type(P)</code>.</p><p>Warning: this function assumes the effects <code>:removable</code> and <code>:consistent</code>. This is necessary to ensure good performance, but imposes precise constraints on your implementation. If adding new methods to <code>tangent_type</code>, you should consult the extended help of <code>Base.@assume_effects</code> to see what this imposes upon your implementation.</p><p><strong>Extended help</strong></p><p>The tangent types which Mooncake.jl uses are quite similar in spirit to ChainRules.jl. For example, tangent &quot;vectors&quot; for</p><ol><li><code>Float64</code>s are <code>Float64</code>s,</li><li><code>Vector{Float64}</code>s are <code>Vector{Float64}</code>s, and</li><li><code>struct</code>s are other another (special) <code>struct</code> with field types specified recursively.</li></ol><p>There are, however, some major differences. Firstly, while it is certainly true that the above tangent types are permissible in ChainRules.jl, they are not the uniquely permissible types. For example, <code>ZeroTangent</code> is also a permissible type of tangent for any of them, and <code>Float32</code> is permissible for <code>Float64</code>. This is a general theme in ChainRules.jl – it intentionally declines to place restrictions on what type can be used to represent the tangent of a given type.</p><p>Mooncake.jl differs from this. <strong>It insists that each primal type is associated to a <em>single</em> tangent type.</strong> Furthermore, this type is <em>always</em> given by the function <code>Mooncake.tangent_type(primal_type)</code>.</p><p>Consider some more worked examples.</p><p><strong>Int</strong></p><p><code>Int</code> is not a differentiable type, so its tangent type is <code>NoTangent</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Int)
NoTangent</code></pre><p><strong>Tuples</strong></p><p>The tangent type of a <code>Tuple</code> is defined recursively based on its field types. For example</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Tuple{Float64, Vector{Float64}, Int})
Tuple{Float64, Vector{Float64}, NoTangent}</code></pre><p>There is one edge case to be aware of: if all of the field of a <code>Tuple</code> are non-differentiable, then the tangent type is <code>NoTangent</code>. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Tuple{Int, Int})
NoTangent</code></pre><p><strong>Structs</strong></p><p>As with <code>Tuple</code>s, the tangent type of a struct is, by default, given recursively. In particular, the tangent type of a <code>struct</code> type is <code>Tangent</code>. This type contains a <code>NamedTuple</code> containing the tangent to each field in the primal <code>struct</code>.</p><p>As with <code>Tuple</code>s, if all field types are non-differentiable, the tangent type of the entire struct is <code>NoTangent</code>.</p><p>There are a couple of additional subtleties to consider over <code>Tuple</code>s though. Firstly, not all fields of a <code>struct</code> have to be defined. Fortunately, Julia makes it easy to determine how many of the fields might possibly not be defined. The tangent associated to any field which might possibly not be defined is wrapped in a <code>PossiblyUninitTangent</code>.</p><p>Furthermore, <code>struct</code>s can have fields whose static type is abstract. For example</p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           x
       end</code></pre><p>If you ask for the tangent type of <code>Foo</code>, you will see that it is</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Foo)
Tangent{@NamedTuple{x}}</code></pre><p>Observe that the field type associated to <code>x</code> is <code>Any</code>. The way to understand this result is to observe that</p><ol><li><code>x</code> could have literally any type at runtime, so we know nothing about what its tangent  type must be until runtime, and</li><li>we require that the tangent type of <code>Foo</code> be unique.</li></ol><p>The consequence of these two considerations is that the tangent type of <code>Foo</code> must be able to contain any type of tangent in its <code>x</code> field. It follows that the fieldtype of the <code>x</code> field of <code>Foo</code>s tangent must be <code>Any</code>.</p><p><strong>Mutable Structs</strong></p><p>The tangent type for <code>mutable struct</code>s have the same set of considerations as <code>struct</code>s. The only difference is that they must themselves be mutable. Consequently, we use a type called <code>MutableTangent</code> to represent their tangents. It is a <code>mutable struct</code> with the same structure as <code>Tangent</code>.</p><p>For example, if you ask for the <code>tangent_type</code> of</p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Bar
           x::Float64
       end</code></pre><p>you will find that it is</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Bar)
MutableTangent{@NamedTuple{x::Float64}}</code></pre><p><strong>Primitive Types</strong></p><p>We&#39;ve already seen a couple of primitive types (<code>Float64</code> and <code>Int</code>). The basic story here is that all primitive types require an explicit specification of what their tangent type must be.</p><p>One interesting case are <code>Ptr</code> types. The tangent type of a <code>Ptr{P}</code> is <code>Ptr{T}</code>, where <code>T = tangent_type(P)</code>. For example</p><pre><code class="language-julia hljs">julia&gt; tangent_type(Ptr{Float64})
Ptr{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chalk-lab/Mooncake.jl/blob/847f357d8b235bbd71416da48827db0e8a98e477/src/tangents.jl#L149-L273">source</a></section></article><p><em><strong>FData and RData</strong></em></p><p>While tangents are the things used to represent gradients and are what high-level interfaces will return, they are not what gets propagated forwards and backwards by rules during AD.</p><p>Rather, during AD, Mooncake.jl makes a fundamental distinction between data which is identified by its address in memory (<code>Array</code>s, <code>mutable struct</code>s, etc), and data which is identified by its value (is-bits types such as <code>Float64</code>, <code>Int</code>, and <code>struct</code>s thereof). In particular, memory which is identified by its address gets assigned a unique location in memory in which its gradient lives (that this &quot;unique gradient address&quot; system is essential will become apparent when we discuss aliasing later on). Conversely, the gradient w.r.t. a value type resides in another value type.</p><p>The following docstring provides the best in-depth explanation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.fdata_type-Tuple{Any}-understanding_mooncake-rule_system" href="#Mooncake.fdata_type-Tuple{Any}-understanding_mooncake-rule_system"><code>Mooncake.fdata_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdata_type(T)</code></pre><p>Returns the type of the forwards data associated to a tangent of type <code>T</code>.</p><p><strong>Extended help</strong></p><p>Rules in Mooncake.jl do not operate on tangents directly. Rather, functionality is defined to split each tangent into two components, that we call <em>fdata</em> (forwards-pass data) and <em>rdata</em> (reverse-pass data). In short, any component of a tangent which is identified by its address (e.g. a <code>mutable struct</code>s or an <code>Array</code>) gets passed around on the forwards-pass of AD and is incremented in-place on the reverse-pass, while components of tangents identified by their value get propagated and accumulated only on the reverse-pass.</p><p>Given a tangent type <code>T</code>, you can find out what type its fdata and rdata must be with <code>fdata_type(T)</code> and <code>rdata_type(T)</code> respectively. A consequence of this is that there is exactly one valid fdata type and rdata type for each primal type.</p><p>Given a tangent <code>t</code>, you can get its fdata and rdata using <code>f = fdata(t)</code> and <code>r = rdata(t)</code> respectively. <code>f</code> and <code>r</code> can be re-combined to recover the original tangent using the binary version of <code>tangent</code>: <code>tangent(f, r)</code>. It must always hold that</p><pre><code class="language-julia hljs">tangent(fdata(t), rdata(t)) === t</code></pre><p>The need for all of this is explained in the docs, but for now it suffices to consider our running examples again, and to see what their fdata and rdata look like.</p><p><strong>Int</strong></p><p><code>Int</code>s are non-differentiable types, so there is nothing to pass around on the forwards- or reverse-pass. Therefore</p><pre><code class="language-julia-repl hljs">julia&gt; fdata_type(tangent_type(Int)), rdata_type(tangent_type(Int))
(NoFData, NoRData)</code></pre><p><strong>Float64</strong></p><p>The tangent type of <code>Float64</code> is <code>Float64</code>. <code>Float64</code>s are identified by their value / have no fixed address, so</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(Float64), rdata_type(Float64))
(NoFData, Float64)</code></pre><p><strong>Vector{Float64}</strong></p><p>The tangent type of <code>Vector{Float64}</code> is <code>Vector{Float64}</code>. A <code>Vector{Float64}</code> is identified by its address, so</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(Vector{Float64}), rdata_type(Vector{Float64}))
(Vector{Float64}, NoRData)</code></pre><p><strong>Tuple{Float64, Vector{Float64}, Int}</strong></p><p>This is an example of a type which has both fdata and rdata. The tangent type for <code>Tuple{Float64, Vector{Float64}, Int}</code> is <code>Tuple{Float64, Vector{Float64}, NoTangent}</code>. <code>Tuple</code>s have no fixed memory address, so we interogate each field on its own. We have already established the fdata and rdata types for each element, so we recurse to obtain:</p><pre><code class="language-julia-repl hljs">julia&gt; T = tangent_type(Tuple{Float64, Vector{Float64}, Int})
Tuple{Float64, Vector{Float64}, NoTangent}

julia&gt; (fdata_type(T), rdata_type(T))
(Tuple{NoFData, Vector{Float64}, NoFData}, Tuple{Float64, NoRData, NoRData})</code></pre><p>The zero tangent for <code>(5.0, [5.0])</code> is <code>t = (0.0, [0.0])</code>. <code>fdata(t)</code> returns <code>(NoFData(), [0.0])</code>, where the second element is <code>===</code> to the second element of <code>t</code>. <code>rdata(t)</code> returns <code>(0.0, NoRData())</code>. In this example, <code>t</code> contains a mixture of data, some of which is identified by its value, and some of which is identified by its address, so there is some fdata and some rdata.</p><p><strong>Structs</strong></p><p>Structs are handled in more-or-less the same way as <code>Tuple</code>s, albeit with the possibility of undefined fields needing to be explicitly handled. For example, a struct such as</p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           x::Float64
           y
           z::Int
       end</code></pre><p>has tangent type</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Foo)
Tangent{@NamedTuple{x::Float64, y, z::NoTangent}}</code></pre><p>Its fdata and rdata are given by special <code>FData</code> and <code>RData</code> types:</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(tangent_type(Foo)), rdata_type(tangent_type(Foo)))
(Mooncake.FData{@NamedTuple{x::NoFData, y, z::NoFData}}, Mooncake.RData{@NamedTuple{x::Float64, y, z::NoRData}})</code></pre><p>Practically speaking, <code>FData</code> and <code>RData</code> both have the same structure as <code>Tangent</code>s and are just used in different contexts.</p><p><strong>Mutable Structs</strong></p><p>The fdata for a <code>mutable struct</code>s is its tangent, and it has no rdata. This is because <code>mutable struct</code>s have fixed memory addresses, and can therefore be incremented in-place. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Bar
           x::Float64
           y
           z::Int
       end</code></pre><p>has tangent type</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Bar)
MutableTangent{@NamedTuple{x::Float64, y, z::NoTangent}}</code></pre><p>and fdata / rdata types</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(tangent_type(Bar)), rdata_type(tangent_type(Bar)))
(MutableTangent{@NamedTuple{x::Float64, y, z::NoTangent}}, NoRData)</code></pre><p><strong>Primitive Types</strong></p><p>As with tangents, each primitive type must specify what its fdata and rdata is. See specific examples for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chalk-lab/Mooncake.jl/blob/847f357d8b235bbd71416da48827db0e8a98e477/src/fwds_rvs_data.jl#L33-L153">source</a></section></article><p><em><strong>CoDuals</strong></em></p><p>CoDuals are simply used to bundle together a primal and an associated fdata, depending upon context. Occassionally, they are used to pair together a primal and a tangent.</p><p><em><strong>A quick aside: Non-Differentiable Data</strong></em></p><p>In the introduction to algorithmic differentiation, we assumed that the domain / range of function are the same as that of its derivative. Unfortunately, this story is only partly true. Matters are complicated by the fact that not all data types in Julia can reasonably be thought of as forming a Hilbert space. e.g. the <code>String</code> type.</p><p>Consequently we introduce the special type <code>NoTangent</code>, instances of which can be thought of as representing the set containing only a <span>$0$</span> tangent. Morally speaking, for any non-differentiable data <code>x</code>, <code>x + NoTangent() == x</code>.</p><p>Other than non-differentiable data, the model of data in Julia as living in a real-valued finite dimensional Hilbert space is quite reasonable. Therefore, we hope readers will forgive us for largely ignoring the distinction between the domain and range of a function and that of its derivative in mathematical discussions, while simultaneously drawing a distinction when discussing code.</p><p>TODO: update this to cast e.g. each possible <code>String</code> as its own vector space containing only the <code>0</code> element. This works, even if it seems a little contrived.</p><h1 id="The-Rule-Interface-(Round-2)"><a class="docs-heading-anchor" href="#The-Rule-Interface-(Round-2)">The Rule Interface (Round 2)</a><a id="The-Rule-Interface-(Round-2)-1"></a><a class="docs-heading-anchor-permalink" href="#The-Rule-Interface-(Round-2)" title="Permalink"></a></h1><p>Now that you&#39;ve seen what data structures are used to represent gradients, we can describe in more depth the detail of how fdata and rdata are used to propagate gradients backwards on the reverse pass.</p><p>Consider the <code>function</code></p><pre><code class="language-julia-repl hljs">julia&gt; foo(x::Tuple{Float64, Vector{Float64}}) = x[1] + sum(x[2])
foo (generic function with 1 method)</code></pre><p>The fdata for <code>x</code> is a <code>Tuple{NoFData, Vector{Float64}}</code>, and its rdata is a <code>Tuple{Float64, NoRData}</code>. The function returns a <code>Float64</code>, which has no fdata, and whose rdata is <code>Float64</code>. So on the forwards pass there is really nothing that needs to happen with the fdata for <code>x</code>.</p><p>Under the framework introduced above, the model for this <code>function</code> is</p><p class="math-container">\[f(x) = (x, x_1 + \sum_{n=1}^N (x_2)_n)\]</p><p>where the vector in the second element of <code>x</code> is of length <span>$N$</span>. Now, following our usual steps, the derivative is</p><p class="math-container">\[D f [x](\dot{x}) = (\dot{x}, \dot{x}_1 + \sum_{n=1}^N (\dot{x}_2)_n)\]</p><p>A gradient for this is a tuple <span>$(\bar{y}_x, \bar{y}_a)$</span> where <span>$\bar{y}_a \in \RR$</span> and <span>$\bar{y}_x \in \RR \times \RR^N$</span>. A quick derivation will show that the adjoint is</p><p class="math-container">\[D f [x]^\ast(\bar{y}) = ((\bar{y}_x)_1 + \bar{y}_a, (\bar{y}_x)_2 + \bar{y}_a \mathbf{1})\]</p><p>where <span>$\mathbf{1}$</span> is the vector of length <span>$N$</span> in which each element is equal to <span>$1$</span>. (Observe that this agrees with the result we derived earlier for functions which don&#39;t mutate their arguments).</p><p>Now that we know what the adjoint is, we&#39;ll write down the <code>rrule!!</code>, and then explain what is going on in terms of the adjoint. This hand-written implementation is to aid your understanding – Mooncake.jl should be relied upon to generate this code automatically in practice.</p><pre><code class="language-julia-repl hljs">julia&gt; function rrule!!(::CoDual{typeof(foo)}, x::CoDual{Tuple{Float64, Vector{Float64}}})
           dx_fdata = x.dx
           function dfoo_adjoint(dy::Float64)
               dx_fdata[2] .+= dy
               dx_1_rdata = dy
               dx_rdata = (dx_1_rdata, NoRData())
               return NoRData(), dx_rdata
           end
           x_p = x.x
           return CoDual(x_p[1] + sum(x_p[2]), NoFData()), dfoo_adjoint
       end;
</code></pre><p>where <code>dy</code> is the rdata for the output to <code>foo</code>. The <code>rrule!!</code> can be called with the appropriate <code>CoDual</code>s:</p><pre><code class="language-julia-repl hljs">julia&gt; out, pb!! = rrule!!(CoDual(foo, NoFData()), CoDual((5.0, [1.0, 2.0]), (NoFData(), [0.0, 0.0])))
(CoDual{Float64, NoFData}(8.0, NoFData()), var&quot;#dfoo_adjoint#1&quot;{Tuple{NoFData, Vector{Float64}}}((NoFData(), [0.0, 0.0])))</code></pre><p>and the pullback with appropriate rdata:</p><pre><code class="language-julia-repl hljs">julia&gt; pb!!(1.0)
(NoRData(), (1.0, NoRData()))</code></pre><p>Observe that the forwards pass:</p><ol><li>computes the result of the initial function, and</li><li>pulls out the fdata for the <code>Vector{Float64}</code> component of the argument.</li></ol><p>As promised, the forwards pass really has nothing to do with the adjoint. It&#39;s just book-keeping and running the primal computation.</p><p>The reverse pass:</p><ol><li>increments each element of <code>dx_fdata[2]</code> by <code>dy</code> – this corresponds to <span>$(\bar{y}_x)_2 + \bar{y}_a \mathbf{1}$</span> in the adjoint,</li><li>sets <code>dx_1_rdata</code> to <code>dy</code> – this corresponds <span>$(\bar{y}_x)_1 + \bar{y}_a$</span> subject to the constraint that <span>$(\bar{y}_x)_1 = 0$</span>,</li><li>constructs the rdata for <code>x</code> – this is essentially just book-keeping.</li></ol><p>Each of these items serve to demonstrate more general points. The first that, upon entry into the reverse pass, all fdata values correspond to gradients for the arguments / output of <code>f</code> &quot;upon exit&quot; (for the components of these which are identified by their address), and once the reverse-pass finishes running, they must contain the gradients w.r.t. the arguments of <code>f</code> &quot;upon entry&quot;.</p><p>The second that we always assume that the components of <span>$\bar{y}_x$</span> which are identified by their value have zero-rdata.</p><p>The third is that the components of the arguments of <code>f</code> which are identified by their value must have rdata passed back explicitly by a rule, while the components of the arguments to <code>f</code> which are identified by their address get their gradients propagated back implicitly (i.e. via the in-place modification of fdata).</p><p><em><strong>Reminder</strong></em>: the first element of the tuple returned by <code>dfoo_adjoint</code> is the rdata associated to <code>foo</code> itself, hence it is <code>NoRData</code>.</p><h1 id="Testing"><a class="docs-heading-anchor" href="#Testing">Testing</a><a id="Testing-1"></a><a class="docs-heading-anchor-permalink" href="#Testing" title="Permalink"></a></h1><p>Mooncake.jl has an almost entirely automated system for testing rules – <code>Mooncake.TestUtils.test_rule</code>. You should absolutely make use of these when writing rules.</p><p>TODO: improve docstring for testing functionality.</p><h1 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h1><p>In this section we have covered the rule system. Every callable object / function in the Julia language is differentiated using rules with this interface, whether they be hand-written <code>rrule!!</code>s, or rules derived by Mooncake.jl.</p><p>At this point you should be equipped with enough information to understand what a rule in Mooncake.jl does, and how you can write your own ones. Later sections will explain how Mooncake.jl goes about deriving rules itself in a recursive manner, and introduce you to some of the internals.</p><h1 id="Asides"><a class="docs-heading-anchor" href="#Asides">Asides</a><a id="Asides-1"></a><a class="docs-heading-anchor-permalink" href="#Asides" title="Permalink"></a></h1><h3 id="Why-Uniqueness-of-Type-For-Tangents-/-FData-/-RData?"><a class="docs-heading-anchor" href="#Why-Uniqueness-of-Type-For-Tangents-/-FData-/-RData?">Why Uniqueness of Type For Tangents / FData / RData?</a><a id="Why-Uniqueness-of-Type-For-Tangents-/-FData-/-RData?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Uniqueness-of-Type-For-Tangents-/-FData-/-RData?" title="Permalink"></a></h3><p>Why does Mooncake.jl insist that each primal type <code>P</code> be paired with a single tangent type <code>T</code>, as opposed to being more permissive. There are a few notable reasons:</p><ol><li>To provide a precise interface. Rules pass fdata around on the forwards pass and rdata on the reverse pass – being able to make strong assumptions about the type of the fdata / rdata given the primal type makes implementing rules much easier in practice.</li><li>Conditional type stability. We wish to have a high degree of confidence that if the primal code is type-stable, then the AD code will also be. It is straightforward to construct type stable primal codes which have type-unstable forwards and reverse passes if you permit there to be more than one fdata / rdata type for a given primal. So while uniqueness is certainly not sufficient on its own to guarantee conditional type stability, it is probably necessary in general.</li><li>Test-case generation and coverage. There being a unique tangent / fdata / rdata type for each primal makes being confident that a given rule is being tested thoroughly much easier. For a given primal, rather than there being many possible input / output types to consider, there is just one.</li></ol><p>This topic, in particular what goes wrong with permissive tangent type systems like those employed by ChainRules, deserves a more thorough treatment – hopefully someone will write something more expansive on this topic at some point.</p><h3 id="Why-Support-Closures-But-Not-Mutable-Globals"><a class="docs-heading-anchor" href="#Why-Support-Closures-But-Not-Mutable-Globals">Why Support Closures But Not Mutable Globals</a><a id="Why-Support-Closures-But-Not-Mutable-Globals-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Support-Closures-But-Not-Mutable-Globals" title="Permalink"></a></h3><p>First consider why closures are straightforward to support. Look at the type of the closure produced by <code>foo</code>:</p><pre><code class="language-julia hljs">function foo(x)
    function bar(y)
        x .+= y
        return nothing
    end
    return bar
end
bar = foo(randn(5))
typeof(bar)

# output
var&quot;#bar#1&quot;{Vector{Float64}}</code></pre><p>Observe that the <code>Vector{Float64}</code> that we passed to <code>foo</code>, and closed over in <code>bar</code>, is present in the type. This alludes to the fact that closures are basically just callable <code>struct</code>s whose fields are the closed-over variables. Since the function itself is an argument to its rule, everything enters the rule for <code>bar</code> via its arguments, and the rule system developed in this document applies straightforwardly.</p><p>On the other hand, globals do not appear in the functions that they are a part of. For example,</p><pre><code class="language-julia hljs">const a = randn(10)

function g(x)
    a .+= x
    return nothing
end

typeof(g)

# output
typeof(g) (singleton type of function g, subtype of Function)</code></pre><p>Neither the value nor type of <code>a</code> are present in <code>g</code>. Since <code>a</code> doesn&#39;t enter <code>g</code> via its arguments, it is unclear how it should be handled in general.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../algorithmic_differentiation/">« Algorithmic Differentiation</a><a class="docs-footer-nextpage" href="../../utilities/defining_rules/">Defining Rules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Friday 9 May 2025 16:48">Friday 9 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
